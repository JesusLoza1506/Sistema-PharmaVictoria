ğŸ›ï¸ Patrones ArquitectÃ³nicos (alto nivel)
1.	Layered Architecture (Capas) âœ…
ğŸ“Œ Sirve para: organizar el sistema en capas (presentaciÃ³n, negocio, datos).
ğŸ› ï¸ En el proyecto: separar la interfaz (pantallas JavaFX), la lÃ³gica de negocio (ventas, descuentos, validaciones) y el acceso a la BD (consultas MySQL).
2.	MVC (Modeloâ€“Vistaâ€“Controlador) âœ…
ğŸ“Œ Sirve para: estructurar la interfaz grÃ¡fica.
ğŸ› ï¸ En el proyecto: cada pantalla tendrÃ¡ sus modelos (productos, clientes), su vista (FXML) y su controlador (clase JavaFX que conecta la UI con los servicios).
3.	Service Layer Pattern âœ…
ğŸ“Œ Sirve para: centralizar reglas de negocio en una capa.
ğŸ› ï¸ En el proyecto: las validaciones, cÃ¡lculos de descuentos o impuestos, y reglas de ventas se concentran en los servicios, no en la interfaz ni en la BD.
4.	Repository Pattern âœ…
ğŸ“Œ Sirve para: manejar la persistencia de datos desde un punto Ãºnico.
ğŸ› ï¸ En el proyecto: todas las operaciones con productos, clientes o ventas pasan por repositorios que abstraen la BD.
5.	Dependency Injection âœ…
ğŸ“Œ Sirve para: desacoplar dependencias y facilitar pruebas.
ğŸ› ï¸ En el proyecto: los controladores no crean manualmente los servicios o repositorios, sino que los reciben listos para usarse.
6.	Clienteâ€“Servidor (matiz agregado) âš ï¸
ğŸ“Œ Sirve para: separar el cliente (app JavaFX) del servidor (MySQL centralizado).
ğŸ› ï¸ En el proyecto: cada sucursal tendrÃ¡ clientes que se conectan a la misma BD central (en red o nube). Es importante remarcarlo porque tienes mÃ¡s de una sucursal.
________________________________________
ğŸ”§ Patrones de DiseÃ±o (GoF aplicados)
7.	Singleton con HikariCP âœ…
ğŸ“Œ Sirve para: asegurar una Ãºnica instancia compartida (pool de conexiones).
ğŸ› ï¸ En el proyecto: todos los mÃ³dulos usarÃ¡n el mismo gestor de conexiones a MySQL.
8.	Factory / Builder âœ…
ğŸ“Œ Sirve para: crear objetos complejos de forma flexible.
ğŸ› ï¸ En el proyecto: generaciÃ³n de comprobantes (boleta, factura) y reportes (ventas filtradas, inventario detallado).
9.	Strategy âœ…
ğŸ“Œ Sirve para: cambiar algoritmos dinÃ¡micamente.
ğŸ› ï¸ En el proyecto: aplicar distintas polÃ­ticas de descuento, bÃºsqueda de productos o cÃ¡lculo de precios sin modificar la lÃ³gica principal.
10.	Observer âœ…
ğŸ“Œ Sirve para: notificar a otros componentes cuando hay cambios.
ğŸ› ï¸ En el proyecto: alertar cuando un producto estÃ¡ por vencer, cuando el stock baja o actualizar el dashboard automÃ¡ticamente.
11.	Command âœ…
ğŸ“Œ Sirve para: encapsular acciones y permitir deshacer o repetir.
ğŸ› ï¸ En el proyecto: registrar ventas o movimientos de inventario con la posibilidad de anularlos o revertirlos si hay errores.
12.	Facade âœ…
ğŸ“Œ Sirve para: simplificar operaciones complejas en una sola interfaz.
ğŸ› ï¸ En el proyecto: un flujo de venta que incluya validar stock, calcular total, generar comprobante y descontar inventario, todo a travÃ©s de una Ãºnica llamada.
13.	Decorator âœ…
ğŸ“Œ Sirve para: aÃ±adir responsabilidades dinÃ¡micamente a un objeto.
ğŸ› ï¸ En el proyecto: extender productos con caracterÃ­sticas especiales (ej. â€œrequiere refrigeraciÃ³nâ€, â€œcontrolado por loteâ€) sin tener que modificar la clase base.


🏛️ Patrones Arquitectónicos (alto nivel)
1.	Layered Architecture (Capas) ✅
📌 Sirve para: organizar el sistema en capas (presentación, negocio, datos).
🛠️ En el proyecto: separar la interfaz (pantallas JavaFX), la lógica de negocio (ventas, descuentos, validaciones) y el acceso a la BD (consultas MySQL).
2.	MVC (Modelo–Vista–Controlador) ✅
📌 Sirve para: estructurar la interfaz gráfica.
🛠️ En el proyecto: cada pantalla tendrá sus modelos (productos, clientes), su vista (FXML) y su controlador (clase JavaFX que conecta la UI con los servicios).
3.	Service Layer Pattern ✅
📌 Sirve para: centralizar reglas de negocio en una capa.
🛠️ En el proyecto: las validaciones, cálculos de descuentos o impuestos, y reglas de ventas se concentran en los servicios, no en la interfaz ni en la BD.
4.	Repository Pattern ✅
📌 Sirve para: manejar la persistencia de datos desde un punto único.
🛠️ En el proyecto: todas las operaciones con productos, clientes o ventas pasan por repositorios que abstraen la BD.
5.	Dependency Injection ✅
📌 Sirve para: desacoplar dependencias y facilitar pruebas.
🛠️ En el proyecto: los controladores no crean manualmente los servicios o repositorios, sino que los reciben listos para usarse.
6.	Cliente–Servidor (matiz agregado) ⚠️
📌 Sirve para: separar el cliente (app JavaFX) del servidor (MySQL centralizado).
🛠️ En el proyecto: cada sucursal tendrá clientes que se conectan a la misma BD central (en red o nube). Es importante remarcarlo porque tienes más de una sucursal.
________________________________________
🔧 Patrones de Diseño (GoF aplicados)
7.	Singleton con HikariCP ✅
📌 Sirve para: asegurar una única instancia compartida (pool de conexiones).
🛠️ En el proyecto: todos los módulos usarán el mismo gestor de conexiones a MySQL.
8.	Factory / Builder ✅
📌 Sirve para: crear objetos complejos de forma flexible.
🛠️ En el proyecto: generación de comprobantes (boleta, factura) y reportes (ventas filtradas, inventario detallado).
9.	Strategy ✅
📌 Sirve para: cambiar algoritmos dinámicamente.
🛠️ En el proyecto: aplicar distintas políticas de descuento, búsqueda de productos o cálculo de precios sin modificar la lógica principal.
10.	Observer ✅
📌 Sirve para: notificar a otros componentes cuando hay cambios.
🛠️ En el proyecto: alertar cuando un producto está por vencer, cuando el stock baja o actualizar el dashboard automáticamente.
11.	Command ✅
📌 Sirve para: encapsular acciones y permitir deshacer o repetir.
🛠️ En el proyecto: registrar ventas o movimientos de inventario con la posibilidad de anularlos o revertirlos si hay errores.
12.	Facade ✅
📌 Sirve para: simplificar operaciones complejas en una sola interfaz.
🛠️ En el proyecto: un flujo de venta que incluya validar stock, calcular total, generar comprobante y descontar inventario, todo a través de una única llamada.
13.	Decorator ✅
📌 Sirve para: añadir responsabilidades dinámicamente a un objeto.
🛠️ En el proyecto: extender productos con características especiales (ej. “requiere refrigeración”, “controlado por lote”) sin tener que modificar la clase base.

